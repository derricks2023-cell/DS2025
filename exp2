#include <bits/stdc++.h>
using namespace std;

class Bitmap {
private:
    unsigned char* M;
    int N, _sz;

protected:
    void init(int n) {
        M = new unsigned char[N = (n + 7) / 8];
        memset(M, 0, N);
        _sz = 0;
    }

public:
    Bitmap(int n = 8) { init(n); }
    ~Bitmap() { delete[] M; }

    int size() const { return _sz; }

    void expand(int k) {
        if (k < 8 * N) return;
        int oldN = N;
        unsigned char* oldM = M;

        init(2 * k);
        memcpy(M, oldM, oldN);
        delete[] oldM;
    }

    void set(int k) {
        expand(k);
        _sz++;
        M[k >> 3] |= (0x80 >> (k & 0x07));
    }

    void clear(int k) {
        expand(k);
        if (_sz > 0) _sz--;
        M[k >> 3] &= ~(0x80 >> (k & 0x07));
    }

    bool test(int k) const {
        if (k >= 8 * N) return false;
        return M[k >> 3] & (0x80 >> (k & 0x07));
    }

    char* bits2string(int n) {
        expand(n - 1);
        char* s = new char[n + 1];
        s[n] = '\0';
        for (int i = 0; i < n; i++)
            s[i] = test(i) ? '1' : '0';
        return s;
    }
};


struct HuffNode {
    char ch;
    int freq;
    HuffNode* left;
    HuffNode* right;

    HuffNode(char c, int f) :
        ch(c), freq(f), left(nullptr), right(nullptr) {}

    HuffNode(HuffNode* l, HuffNode* r) :
        ch(0), freq(l->freq + r->freq), left(l), right(r) {}
};

struct cmp {
    bool operator()(HuffNode* a, HuffNode* b) const {
        return a->freq > b->freq;
    }
};

class HuffmanTree {
public:
    HuffNode* root;
    map<char, Bitmap*> codes;
    map<char, int> codeLen;

    HuffmanTree() : root(nullptr) {}

    ~HuffmanTree() {
        freeNode(root);
    }

    void freeNode(HuffNode* node) {
        if (!node) return;
        freeNode(node->left);
        freeNode(node->right);
        delete node;
    }

    void generateCode(HuffNode* node, Bitmap& path, int depth) {
        if (!node) return;

        if (!node->left && !node->right) {
            if (node->ch >= 'a' && node->ch <= 'z') {
                Bitmap* bm = new Bitmap(depth ? depth : 1);
                codeLen[node->ch] = depth ? depth : 1;

                for (int i = 0; i < codeLen[node->ch]; i++) {
                    if (path.test(i)) bm->set(i);
                    else bm->clear(i);
                }
                codes[node->ch] = bm;
            }
            return;
        }

        path.clear(depth);
        generateCode(node->left, path, depth + 1);

        path.set(depth);
        generateCode(node->right, path, depth + 1);
    }

    void buildFromText(const string& text) {
        vector<int> freq(26, 0);
        for (char ch : text) {
            if (isalpha((unsigned char)ch)) {
                freq[tolower(ch) - 'a']++;
            }
        }

        priority_queue<HuffNode*, vector<HuffNode*>, cmp> pq;

        for (int i = 0; i < 26; i++) {
            if (freq[i] > 0)
                pq.push(new HuffNode('a' + i, freq[i]));
        }

        if (pq.empty()) {
            root = nullptr;
            return;
        }

        if (pq.size() == 1) {
            HuffNode* only = pq.top(); pq.pop();
            HuffNode* fake = new HuffNode('\0', 0);
            pq.push(only);
            pq.push(fake);
        }

        while (pq.size() > 1) {
            HuffNode* a = pq.top(); pq.pop();
            HuffNode* b = pq.top(); pq.pop();
            pq.push(new HuffNode(a, b));
        }

        root = pq.top();

        Bitmap path(128);
        generateCode(root, path, 0);
    }

    string encodeWord(const string& w) {
        string result = "";
        for (char c : w) {
            if (!isalpha((unsigned char)c)) continue;
            char ch = tolower(c);
            if (codes.count(ch) == 0) continue;

            int len = codeLen[ch];
            Bitmap* bm = codes[ch];
            for (int i = 0; i < len; i++)
                result += (bm->test(i) ? '1' : '0');
        }
        return result;
    }
};


int main() {
    string text =
"I have a dream that one day this nation will rise up and live out the true meaning "
"of its creed: 'We hold these truths to be self-evident, that all men are created equal.' "
"I have a dream that one day on the red hills of Georgia the sons of former slaves and the "
"sons of former slave-owners will be able to sit down together at the table of brotherhood.";

    HuffmanTree ht;
    ht.buildFromText(text);

    cout << "=== Huffman Codes ===\n";
    for (auto& p : ht.codes) {
        char* s = p.second->bits2string(ht.codeLen[p.first]);
        cout << p.first << " : " << s << endl;
        delete[] s;
    }

    cout << "\n=== Encode Words ===\n";
    cout << "dream   => " << ht.encodeWord("dream") << endl;
    cout << "freedom => " << ht.encodeWord("freedom") << endl;
    cout << "hope    => " << ht.encodeWord("hope") << endl;

    return 0;
}
