#include <iostream>
#include <vector>
#include <algorithm>
#include <chrono>
#include <random>
#include <cmath>
#include <iomanip>

using namespace std;

// ===========================
// 边界框结构体
// ===========================
struct Box {
    float x1, y1, x2, y2;
    float score;
};

// IoU计算
float IoU(const Box &a, const Box &b) {
    float xx1 = max(a.x1, b.x1);
    float yy1 = max(a.y1, b.y1);
    float xx2 = min(a.x2, b.x2);
    float yy2 = min(a.y2, b.y2);

    float w = max(0.0f, xx2 - xx1);
    float h = max(0.0f, yy2 - yy1);

    float inter = w * h;
    float areaA = (a.x2 - a.x1) * (a.y2 - a.y1);
    float areaB = (b.x2 - b.x1) * (b.y2 - b.y1);

    return inter / (areaA + areaB - inter + 1e-5);
}

// ===========================
// 基础 NMS
// ===========================
vector<Box> NMS(vector<Box> boxes, float iou_threshold) {
    // 默认按置信度降序排列
    sort(boxes.begin(), boxes.end(), [](const Box &a, const Box &b) {
        return a.score > b.score;
    });

    vector<Box> result;

    vector<bool> removed(boxes.size(), false);

    for (size_t i = 0; i < boxes.size(); i++) {
        if (removed[i]) continue;
        result.push_back(boxes[i]);

        for (size_t j = i + 1; j < boxes.size(); j++) {
            if (!removed[j] && IoU(boxes[i], boxes[j]) > iou_threshold) {
                removed[j] = true;
            }
        }
    }
    return result;
}

// ===========================
// 四种排序算法实现
// (对 Box 按 score 从大到小排序)
// ===========================

// 1. 冒泡排序
void bubbleSort(vector<Box>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j].score < arr[j+1].score)
                swap(arr[j], arr[j+1]);
        }
    }
}

// 2. 插入排序
void insertionSort(vector<Box>& arr) {
    for (int i = 1; i < arr.size(); i++) {
        Box key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j].score < key.score) {
            arr[j+1] = arr[j];
            j--;
        }
        arr[j+1] = key;
    }
}

// 3. 归并排序
void merge(vector<Box>& arr, int l, int m, int r) {
    vector<Box> L(arr.begin()+l, arr.begin()+m+1);
    vector<Box> R(arr.begin()+m+1, arr.begin()+r+1);

    int i = 0, j = 0, k = l;
    while (i < L.size() && j < R.size()) {
        if (L[i].score >= R[j].score) arr[k++] = L[i++];
        else arr[k++] = R[j++];
    }
    while (i < L.size()) arr[k++] = L[i++];
    while (j < R.size()) arr[k++] = R[j++];
}

void mergeSort(vector<Box>& arr, int l, int r) {
    if (l < r) {
        int m = (l+r)/2;
        mergeSort(arr, l, m);
        mergeSort(arr, m+1, r);
        merge(arr, l, m, r);
    }
}

// 4. 快速排序
int partition_qs(vector<Box>& arr, int low, int high) {
    float pivot = arr[high].score;
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j].score >= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i+1], arr[high]);
    return i + 1;
}

void quickSort(vector<Box>& arr, int low, int high) {
    if (low < high) {
        int pi = partition_qs(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// ===========================
// 数据生成
// ===========================
vector<Box> generateRandom(int n) {
    vector<Box> boxes(n);
    random_device rd;
    mt19937 gen(rd());
    uniform_real_distribution<float> dist(0, 1);

    for (int i = 0; i < n; i++) {
        float x1 = dist(gen) * 0.8;
        float y1 = dist(gen) * 0.8;
        float w = dist(gen) * 0.2;
        float h = dist(gen) * 0.2;

        boxes[i] = {x1, y1, x1+w, y1+h, dist(gen)};
    }
    return boxes;
}

vector<Box> generateCluster(int n) {
    vector<Box> boxes(n);
    random_device rd;
    mt19937 gen(rd());
    uniform_real_distribution<float> dist(0, 1);
    normal_distribution<float> cluster(0.5, 0.15); // 聚集中心

    for (int i = 0; i < n; i++) {
        float x1 = min( max(cluster(gen), 0.0f), 0.9f );
        float y1 = min( max(cluster(gen), 0.0f), 0.9f );
        float w = dist(gen) * 0.1;
        float h = dist(gen) * 0.1;
        boxes[i] = {x1, y1, x1+w, y1+h, dist(gen)};
    }
    return boxes;
}

// ===========================
// 计时器
// ===========================
template <typename F>
long long measure(F func) {
    auto start = chrono::high_resolution_clock::now();
    func();
    auto end = chrono::high_resolution_clock::now();
    return chrono::duration_cast<chrono::milliseconds>(end - start).count();
}

// ===========================
// 主程序
// ===========================
int main() {
    vector<int> sizes = {100, 1000, 5000, 10000};

    for (int size : sizes) {
        cout << "\n===== 数据规模: " << size << " =====\n";

        // 2 种数据分布
        vector<vector<Box>> datasets = {
            generateRandom(size),
            generateCluster(size)
        };
        vector<string> names = {"随机分布", "聚集分布"};

        for (int d = 0; d < 2; d++) {
            cout << "\n--- " << names[d] << " ---\n";

            // 四种排序算法测试
            {
                auto data = datasets[d];
                long long t = measure([&]() { bubbleSort(data); });
                cout << "冒泡排序时间: " << t << " ms\n";
            }
            {
                auto data = datasets[d];
                long long t = measure([&]() { insertionSort(data); });
                cout << "插入排序时间: " << t << " ms\n";
            }
            {
                auto data = datasets[d];
                long long t = measure([&]() { mergeSort(data, 0, data.size()-1); });
                cout << "归并排序时间: " << t << " ms\n";
            }
            {
                auto data = datasets[d];
                long long t = measure([&]() { quickSort(data, 0, data.size()-1); });
                cout << "快速排序时间: " << t << " ms\n";
            }

            // NMS 性能
            {
                auto data = datasets[d];
                long long t = measure([&]() { NMS(data, 0.5); });
                cout << "NMS运行时间: " << t << " ms\n";
            }
        }
    }

    return 0;
}
